---
title: "Diversity analysis"
author: "ISME Latin America"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document: 
    fig_height: 8
    fig_width: 13
    number_section: yes
    theme: paper
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
---
# `phyloseq` and diversity analysis introduction

## Packages needed

First, we'll make vectors with the names of the necessary packages.
```{r}
#the packages immediately available in CRAN
cran_packages <- c("bookdown", "knitr", "tidyverse", "plyr", "grid", "gridExtra", "kableExtra", "xtable", "ggpubr")
#the ones that use Bioconductor
bioc_packages <- c("phyloseq", "dada2", "DECIPHER", "phangorn", "ggpubr", "BiocManager","DESeq2", "microbiome", "philr")
#packages that are still in GitHub
git_source <- c("twbattaglia/btools", "gmteunisse/Fantaxtic", "MadsAlbertsen/ampvis2", "opisthokonta/tsnemicrobiota")# fuente/nombre del paquete
git_packages <- c("btools", "fantaxtic", "ampvis2", "tsnemicrobiota") # nombre del paquete
```
Now we install the packages.

**NOTE: JUST RUN IT ONCE, AFTER DOWNLOADING, DON'T EXECUTE AGAIN.**
```
# CRAN
.inst <- cran_packages %in% installed.packages()#The %in% operator in R can be used to identify if an element (e.g., a number) belongs to a vector or dataframe
if(any(!.inst)) {
  install.packages(cran_packages[!.inst])
}
#BioConductor
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
.inst <- bioc_packages %in% installed.packages()
if(any(!.inst)) {
  BiocManager::install(bioc_packages[!.inst])
}
#GitHub
.inst <- git_source %in% installed.packages()
if(any(!.inst)) {
  devtools::install_github(git_source[!.inst])
}
```
Now let's load the packages.
```{r, warning=FALSE, message=FALSE}
sapply(c(cran_packages, bioc_packages, git_packages), require, character.only = TRUE) #had a little trouble with philr
```

## What can we do with `phyloseq`
`Phyloseq`is a package from Bioconductor for analysis and manipulation of metagenomic data obtained from high yield sequencing. It allows us to save, import, analyze and visualize the sequencing data after being processed in the first place as in obtaining the ASVs or OTUs, including associated data, associated observation tables of each sample, phylogeny, or taxonomic identification. The objects produced have four components that store the read count, the metadata, taxonomy, and phylogenetic trees. We can see a complete diagram of `phyloseq` in this image. 
![](http://www.castrolab.org/isme/biodiversity/images/phyloseq_structure.png)

## Start working with the data

First, we'll use the `phyloseq`object called ```ps```. If you don't have a ```ps``` object, you can download it from  [here](https://www.dropbox.com/s/df1aie9angv16gk/ps.RDS?dl=0).

```{r}
psd <- readRDS("C:/Users/fotgo/Downloads/ps.RDS") #CHANGE ME to directory with the object
#this time it is a readRDS 'cause of the nature of the object
psd
```

# Quality control of 16S analysis

We check for the prevalence of the taxonomic features.

We create a data frame with the prevalence values, then we add the taxonomy and we graph.
```{r}
prevdf <- apply(X = otu_table(psd),#the otu table from the psd object
               MARGIN = ifelse(taxa_are_rows(psd), yes = 1, no = 2),
               FUN = function(x){sum(x > 0)})#gives the prevalence of the otu table

prevdf <- data.frame(Prevalence = prevdf,
                    TotalAbundance = taxa_sums(psd),
                    tax_table(psd))#creates the object with the prevalence of the otu table and the taxa names of each one, also de abundance

plyr::ddply(prevdf, "Phylum", function(df1){cbind(mean(df1$Prevalence),sum(df1$Prevalence))}) -> dfprev #subsets the data from the data frame that was previously created and shows the phylum and the mean of the prevalence and the sum of said prevalence
kable(dfprev)#puts the data in a more attractive table
```


We can extract some information directly from the table, so we may start interpreting a little. In first place, there are some phylum more represented than others. The column **1** has the mean of the read count, while the column **2** has the sum of these. Some phylum are represented by just one read, so we'll remove the less represented phylums as to avoid false positives.

## Filter the undesired taxa
```{r}
# Here we define which taxa we're going to take out, they are completely arbitrary
filterPhyla <- c("BRC1", "Deinococcus-Thermus", "Gemmatimonadetes", "Kiritimatiellaeota", "Nanoarchaeaeota", "Ochrophyta", "Schekmanbacteria", "Ciliophora", "Spirochaetes", NA)

# The actual filter
(psd1 <- subset_taxa(psd, !Phylum %in% filterPhyla))

# We also filter reads that correspond to thins that aren't microorganisms
# next we just filter using a specialized function

filterPhyla2 <- c("Chloroplast", "Mitochondria", "Eukaryota")
psd1 <- subset_taxa(psd1, !Kingdom %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Phylum %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Class %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Order %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Family %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Genus %in% filterPhyla2)
```

We can also make other types of sub-setting the data. We can filter based on the mean read counts, with their distribution, and filtering samples with a low number of minimum reads.

```{r}
# Filtered based on an arbitrary threshold of the mean read count, in this case we select 1e-5
psd2 <- filter_taxa(psd1, function(x) mean(x) > 1e-5, TRUE)

# We can also remove those thaxa that are not observed an X amount of times at least in 10% of the samples
psd3 <- filter_taxa(psd2, function(x) sum(x > 2) > (0.1*length(x)), TRUE)

# Finally, we can filter samples with less of an arbitrary number, in this case 1000 reads
psd4 <- prune_samples(sample_sums(psd3) > 1000, psd3)

psd4
```

Now, we can filter even more if we desire. The next filter is based on a threshold and then visualizing the effect graphically. 
```{r}
# Selecting taxa
prevdf1 <- subset(prevdf, Phylum %in% get_taxa_unique(psd4, "Phylum"))
ggplot(prevdf1, aes(TotalAbundance, Prevalence / nsamples(psd),color=Phylum)) +
# A line for it to be clearer
  geom_hline(yintercept = 0.05, alpha = 0.5, linetype = 2) +  geom_point(size = 2, alpha = 0.7) +
  scale_x_log10() +  xlab("Total Abundance") + ylab("Prevalence [Frac. Samples]") +
  facet_wrap(~Phylum) + theme(legend.position="none")
```
```{R}
# We define the prevalence threshold at 5%
prevalenceThreshold <- 0.05 * nsamples(psd4)#nsamples gets the number of the samples
```
```{R}
# Execute prevalence filter, using `prune_taxa()` function
keepTaxa <- rownames(prevdf1)[(prevdf1$Prevalence >= prevalenceThreshold)]
psd5 <- prune_taxa(keepTaxa, psd4)
```

While we use ``DADA2```, the taxa sequence or ASV is determined, but in this case we'll just work at community level. For this purpose the names will be changed with correlative codes for better understanding down the line.

```{r}
# Change the sequences for a generic name
taxa_names(psd5) <- paste0("ASV", seq(ntaxa(psd5)))
```

Now that the reads have been filtered, our `phyloseq` object is ready for use and can be visualized. First we'll graph the read counts by sample so that we can have an idea of their distribution.

```{r}
#make a data frame with the sums of the read counts
sample_sum_df <- data.frame(sum <- sample_sums(psd5))

#graph
ggplot(sample_sum_df, aes(x = sum)) + 
  geom_histogram(color = "black", fill = "grey", binwidth = 2500) +
  ggtitle("Distribution of sample sequencing depth") + 
  xlab("Read counts") +
  theme(axis.title.y = element_blank()) 
```

Finally, we calculate the rarefaction curve for each sample, so that we can determine if the sequencing was enough or if more sequencing is needed. This analysis let us estimate if we could find more OTUs or ASVs if more sequencing is done.

```{r, warning=FALSE, message=FALSE}
# Loading some previously done scripts
scripts <- c("graphical_methods.R",
             "tree_methods.R",
             "plot_merged_trees.R",
             "specificity_methods.R",
             "ternary_plot.R",
             "richness.R",
             "edgePCA.R",
             "copy_number_correction.R",
             "import_frogs.R",
             "prevalence.R",
             "compute_niche.R")
urls <- paste0("https://raw.githubusercontent.com/mahendra-mariadassou/phyloseq-extended/master/R/", scripts)

for (url in urls) {
  source(url)
}
```

Now we graph.

```{r, warning=FALSE, message=FALSE, results='hide', fig.show='hide'}
p <- ggrare(psd5, step = 100, color = "species", label = "sample_ID", se = TRUE)
#ggrare makes a rarefaction curve using ggplot2
```
```{r, warning=FALSE, message=FALSE}
#nice graph, just separates by species
(p <- p + facet_wrap(~species))+theme(
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"))
```


The graphs are separated by species, in this case they are different whale species; *Balaenoptera musculus*, *Balaenoptera physalus*, *Eubalaena australis*, and *Megaptera novaeangliae*. The samples show the number of taxa according to the sampling size or number of reads. *Balaenoptera musculus*' samples as well as *Megaptera novaeangliae*'s show the desired plateau, meaning more sequencing is not really needed. On the other hand, *Balaenoptera physalus*'s samples do not reach the expected plateau, so more sequencing may yield OTUs/ASVs that do not show in this samples, so the alpha diversity is underestimated.

# Structure and manipulation of a `phyloseq`object

Some times we want to analyse a subset of the samples in our `phyloseq`object, or rather, we want to select certain taxonomic groups for future analysis. `phyloseq`allows us to make a variety of filters in order to do so. We'll first visualize the table with the information from our `phyloseq`object.

```{r}
#read count table
kable(head(otu_table(psd5)), "html") %>%
    kable_styling() %>%
    scroll_box(width = "800px", height = "300px")
```

The OTU table shows the relationship of the name of the taxa with the samples and the mapped reads against said reads. Here the read count is directly proportional to the number of times a taxon is observed. 
We'll see now the taxonomy table.

```{r}
#taxonomy table
kable(head(tax_table(psd5)), "html") %>%
    kable_styling() %>%
    scroll_box(width = "800px", height = "300px")
```

The tax table shows the relationship between the taxa and their taxonomic lineage, i.e., it links a sequence variance, or ASV, with the taxonomic levels from kingdom all the way to genus or species, depending on the resolution level of the analysis.
Now we'll visualize metadata from our object.

```{r}
#metadata table
kk<-data.frame(head(sample_data(psd5)))
kable(kk, "html") %>%
    kable_styling() %>%
    scroll_box(width = "800px", height = "300px")
```

Finally, in this case the `phyloseq`object includes a phylogenetic tree. This tree shows the evolutionary relationships among the samples' taxa. It may not always be present since when sequencing a universal probe may be absent, so there is no phylogeny.
Now we plot the tree.

```{r}
# tree from our  phyloseq object
plot_tree(psd5, method = "treeonly", ladderize = "left")
```

Other packages make use of the `phyloseq`objects, such as `microbiome`and àmpvis`. To see the global data of our object, we can do the following.

```{r}
summarize_phyloseq(psd5)
```

The previous command also shows the minimum and the maximum reads, the total and the means of said reads as well as other information such as the names of our columns in the metadata table. For now, we can also visualize a mix in which the taxonomy and the taxon abundance for each sample is showed.

```{r}
df<- psmelt(psd5)
#psmelt is a function for phyloseq objects and is usually used for graphs. It is dependent of melt and merge functions
kable(head(df), "html") %>%
    kable_styling() %>%
    scroll_box(width = "800px", height = "300px")
```

In order to have a visual representation of the sample distribution, we can graph, for example, in this case based upon the geographic locations that are stored in the metadata for each of the species.

```{r}
res<- plot_frequencies(sample_data(psd5), "geo_loc_name", "species")#the plot frequency function must be given a factor, which i taken from the sample_data, so there is more information in the plot than just the plot itself and its parameters
#obviously, the distribution can only be made with the data within the object, in this case the location was saved as "geo_loc_name" and the species in the columns with the same name
res
```
```{r}
#just a table with the infromation within the "res" object that we made
kable(res$data[-length(res$data)], "html") %>%
    kable_styling() %>%
    scroll_box(width = "800px", height = "300px")
```

Now, one more time we can subset the information within the `phyloseq` object with a series of functions, such as `fiter`,`subset`, and `prune`. We've filtered our data before using the function `filter_data` on the object `psd5`; this returned the mean of the read counts for each taxa and if it yielded a value less than 1e-5, it was eliminated from the object. Now we'll see another way of filtering based on the abundance.

First we'll transform the relative abundance and then filter them.
```{r}
#transform the reads into percentages
psd5r<-transform_sample_counts(psd5,function(x) x / sum (x))#transforms the reads from an abundance matrix based on a user-defined function. Each read count is transformed individually

#filter the taxa that have an abundance below 1%
(psd5r.filtered<-filter_taxa(psd5r, function(x) sum(x) > 1, TRUE))#analogous to .genefilter . It returns a logical vectorif the OTUs passed the criteria or not
```

So, how many taxa remain in the `phyloseq`object? After pruning our samples, we see the abundance is very low, therefore a lot of taxa are eliminated.

Now, we'll do the filtering as if we are trying to filter based on specific taxa.
```{r}
#visualize the remaining taxa
tax_table(psd5r.filtered)

#filtering on the genus "Moraxella"
(subset_taxa(psd5r.filtered, Genus=="Moraxella")->psd5r.filtered.moraxella)

#we can also filtered everything except for the Moraxella
(subset_taxa(psd5r.filtered, Genus!="Moraxella")->psd5r.filtered.Nomoraxella)
```

Another way of filtering a `phyloseq`object is filtering based on an attribute within the `sample_data`. For example, with these precise data, we could study the microbiome of each whale by separate. We would create 3 `phyloseq` objects from the original `psd5`object.

```{r}
#Balaenoptera musculus
(psd5.blue <- subset_samples(psd5, species == "Balaenoptera musculus"))

#Balaenoptera physalus
(psd5.fin <- subset_samples(psd5, species == "Balaenoptera physalus"))

#Megaptera novaeangliae
(psd5.joro <- subset_samples(psd5, species == "Megaptera novaeangliae"))
```

Alternatively, we could study just 3 out of the 4 whale species that are originally in the `psd5` object.

```{r}
psd5 <- subset_samples(subset_samples(psd5, species != "Eubalaena australis"))
```

The function `prune_samples`is also largely used since it allows for the use of a vector with the reads we wish to keep (similarly to `subset_samples`) or a logical vector in which the samples we want to keep are True.

```{r}
# Select only the genus _Moraxella_
subset_taxa(psd5, Genus=="Moraxella") -> psd5.moraxella

#We keep only the samples that comply with the condition, meaning the abundance of _Moraxella_ of more tha 5 reads in this case
prune_samples(sample_sums(psd5.moraxella)>=5, psd5.moraxella) -> psd5.moraxella

# Visualizing the data in a phylogenetic tree
plot_tree(psd5.moraxella, color="species", shape="Family", label.tips="Genus", size="abundance")
```
We can immediately realize that *Moraxella* is mostly distributed within the *Megaptera novaeangliae* when compared with the other 2 whale species.

Other thing that can is usually done is removing contaminants or undesired taxa. This can be easily done with the function `prune_taxa`.

```{r}
# Defining the undesired taxa
badTaxa <- c("ASV134", "ASV104", "ASV68")

# Create a list with all the names of the taxa within the object psd5
allTaxa <- taxa_names(psd5)

# Keep the difference in taxa between badTaxa and allTaxa 
keepTaxa <- allTaxa[!(allTaxa %in% badTaxa)]

#Actually pruning the taxa
(psd5.prune <- prune_taxa(keepTaxa, psd5))
```

Finally, other useful functions in the `phyloseq` package are `tax_gloom` and `tip_gloom`. Both functions groups the objectd based on a certain property. For example, it is highly probable that one encounters ASVs from the same genus even though they might be slightly different. We hace already done this when filtering based on the *Moraxella* genus. The resulting object had 8 taxa, all of them belonging ro *Moraxella*.

In order to visualize and analyse the data it is often convenient collpasinf or grouping the sequences of the same genus or any other taxonomic level. Also, `tip_gloom` makes something similar but based on an arbitrary *height* in the phylogenetic tree.

```{r}
# Group by genus
psd5.genus <- tax_glom(psd5, "Genus", NArm = FALSE)
# group by phylogentic tree height
h1 <- 0.4
psd5.tip <- tip_glom(psd5, h = h1)
# Graph the comparison in order to see the differences 
multiPlotTitleTextSize <- 15
p2tree <- plot_tree(psd5, method = "treeonly",
                   ladderize = "left",
                   title = "Without grouping") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p3tree <- plot_tree(psd5.genus, method = "treeonly",
                   ladderize = "left", title = "Genus level") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p4tree <- plot_tree(psd5.tip, method = "treeonly",
                   ladderize = "left", title = "By height") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))

# Graph all trees together
grid.arrange(nrow = 1, p2tree, p3tree, p4tree)
```

# Indtroduction to diversity analysis

In community studies, the concept of biodiversity is that of the communities' ecology in which we are interested in the species richness (number of different species in a community/ alpha diversity), the differences and similarities between communities (beta diversity), and in some cases, the total diversity from a region or ecological landscape (gamma diversity).

![](http://www.castrolab.org/isme/biodiversity/images/diversidad.png)

In the picture above we can observe the bird diversity in two regions, **X** and **Y** spread into four different sites (image taken from the [Community Ecology of Mittelbach](https://global.oup.com/academic/product/community-ecology-9780878935093?cc=cl&lang=en&)). The alpha diversity is bigger in the sites 1 and 3 with 5 total species in each one. The beta diversity indexes the change or turnover of species between the sites. In the figure, the region **Y** has a bigger beta diversity when compared with the **X** region because the turnover between site 2 and 4 is bigger than that of sites 1 and 3 (which have the same 5 species). The gamma diversity index the total diversity in the region, therefore in this example the gamma diversity is bigger in the **Y** region since it has a total of 6 species, compared to the **X** region which has 5 species.

## Richness indexes, uniformity, dominance, and phylogenetic diversity (alpha diversity)

When talking in a metagenomic context, the alpha diversity is determined by a series of measurements that are taken from ecology which allows to to characterize a microbial community. `phyloseq` has a useful function able to to calculate and graph up to seven measures, i.e. Observed (simply the number of taxa), Chao1 (adjusted richness by the probability of not observing the species), ACE (richness that accounts for relative abundance), Shannon (relative abundance of taxa), Simpson (1-the probability of randomly observing two bacteria in a community that belong to different species), Inverse Simpson (1/Simpson), and Fisher (richness accounting the abundance). With `pjyloseq`, we can use the function `plot_richness` in order to see different diversity 

```{r}
plot_richness(psd5, color = "species", x="species", measures = c("Observed", "Chao1","Shannon")) + geom_boxplot(aes(fill = species), alpha=.7) + scale_color_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f")) + scale_fill_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f"))
```

In the previous example, we only graphed Observed, Chao1, and Shannon using the argument `measures = c("Observed", "Chao1", "Shannon")`. If we wish to obtain all the measures we can simply omit writing the argument and will show everything by default. 

Now, we'll try to answer if the alpha diversity is significantly different due to the whale species. This can be proved with an ANOVa analysis. For this example we'll be using a diversity index that is not incorporated in `phyloseq`. *Faith's Phylogenetic Diversity* index was introduced by Daniel Faith in 1992; it does not only consider the number of species but also accounts for how much do the species relate phylogentically. The previous statement is relevant since it returns a quick measurement to evaluate the ecosystem's conservation priorities, or if it consists of a microbial community where tere is a bigger chance of finding novel genetic functions.

```{r}
# Saving a dataframe with the measuremtns of the alpha diveristy
# Estimate the Faiths phylogenetic diverstiy from an OTU table and phylogenetic tree
alpha_pd <- estimate_pd(psd5)
# combine the metadata with alpha.diversity
data <- cbind(sample_data(psd5), alpha_pd) 
# Calculate an ANOVA
psd5.anova <- aov(PD ~ species, data) #apparently there is signifficative difference depending on the species
# install.packages("xtable")
library(xtable)
psd5.anova.table <- xtable(psd5.anova)
kable((psd5.anova.table), "html") %>%
    kable_styling() %>%
    scroll_box(width = "800px", height = "150px")
```

The package `microbiome` easily offers the necessary tools to evaluate diversity through the function `global`.

```{r}
tab<-global(psd5, index = "all") # Global indicators of the ecosystem state, including richness, evenness, diversity, and other indicators
kable((head(tab)), "html") %>%
    kable_styling() %>%
    scroll_box(width = "800px", height = "150px")
```

Speaking technically, the `global` function returns 26 diversity measurements that help us understand the structure on the microbial communities. In general, this measurements divide into richness, diversity, dominance, rarity, coverage, and uniformity.

The package `microbiome` offers fucntions to calculate each one of the aspects of the microbial community.

```{r}
# richness
tab <- richness(psd5)
tab
# dominance
tab <- dominance(psd5, index = "all")
tab
# rarity
tab <- rarity(psd5, index = "all")
tab
# coverage
tab <- coverage(psd5, threshold = 0.5)
tab
# inequality
tab <- inequality(psd5)
tab
# uniformity
tab <- evenness(psd5, "all")
tab
```

Lets see an example estimating the diversity, graphing the results, and calculating the statistic significance. For this example, we'll be using the `ggpubr` library, which generates "publication-ready plots", something that is always desirable. 

```{r}
library(ggpubr)

# We generate a phyloseq object named "object" without taxa that sum up to 0 reads 
psd5.2 <- prune_taxa(taxa_sums(psd5) > 0, psd5)
# We calculate the diversity indexes
tab <- diversities(psd5.2, index = "all")
# visualize the results
kable((head(tab)), "html") %>%
    kable_styling() %>%
    scroll_box(width = "800px", height = "150px")
```

Now we extract the metadata.

```{r}
psd5.2.meta<-meta(psd5.2) #This function retrieves the sample_data as a data.frame
head(psd5.2.meta)
```

Now we add the diversity table to the metadata.

```{r}
psd5.2.meta$Shannon <- tab$diversity_shannon
psd5.2.meta$InverseSimpson <- tab$diversity_inverse_simpson
```

In this exercise we are interested in comparing the diversities between whales' species, therefore we need to keep in mind we have the data for 3 whale species: *Megaptera novaeangliae*, *Balaenoptera musculus*, and *Balaenoptera physalus*. We need to create a list of pair comparisons in order to visualize and calculate the statistic significance simultaneously.

```{r}
# Obtain the varaibles from the phyloseq object
spps <- levels(psd5.2.meta$species) #provides access to the levels attribute of a variable
# We create a list of the things we wish to compare
pares.spps <- combn(seq_along(spps), 2, simplify = FALSE, FUN = function(i)spps[i])
# function combn: Generate all combinations of the elements of x taken m at a time
#function seq_along: Generate regular sequences. seq is a standard generic with a default method. seq.int is a primitive which can be much faster but has a few restrictions. seq_along and seq_len are very fast primitives for two common cases.

# See the results
pares.spps
```

With the `ggviolin` function we can generate a violin graph in a single step.

```{r}
p1 <- ggviolin(psd5.2.meta, x = "species", y = "Shannon",
 add = "boxplot", fill = "species", palette = c("#a6cee3", "#b2df8a", "#fdbf6f"))  
p1
```

Now we evaluate the statistic significance between the whales' diversity estimates. Now again, we have the paper-ready figure.

```{r}
p1 <- p1 + stat_compare_means(comparisons = pares.spps)
p1
```

## Miltidimentional scaling and Beta diversity (Bray-Curtis, UniFrac, t-SNE)

Referring to beta diversity, we can calculate the global similarity with all or samples of interest or we can also quantify the group¿s divergence and compare it with another group.

We now see it in the example below.

```{r}
# Calculating the blue whale and humpback's divergence
# divergence()=Quantify microbiota divergence (heterogeneity) within a given sample set with respect to a reference.
# abundances()=Retrieves the taxon abundance table from phyloseq-class object and ensures it is systematically returned as taxa x samples matrix.

# NEED TO CHECK WHAT YOU'RE COMPARING AGAINST 
div.azul <- divergence(subset_samples(psd5, species == "Balaenoptera musculus"), 
                       abundances(psd5),method = "bray")
div.joro <- divergence(abundances(subset_samples(psd5, species == "Megaptera novaeangliae")), 
                       abundances(psd5), method = "bray")

# transforming the data into _dataframes_
data.frame(div.azul) -> df.div.azul
data.frame(div.joro) -> df.div.joro

df.div.azul<-as.data.frame(t(df.div.azul))
df.div.joro<-as.data.frame(t(df.div.joro))

# assign a name to the column
colnames(df.div.azul)<-"divergence"
colnames(df.div.joro)<-"divergence"

# Adding columns to the _dataframes_ with the whales' common names
df.div.azul$species<-"Blue Whale"
df.div.joro$species<-"Humpback Whale"

# We combine and generate a single dataframe
rbind(df.div.joro, df.div.azul) -> div.boxplot

#plot and statistical comparisons
p2 <- ggboxplot(data = div.boxplot, x = "species", y = "divergence", fill = "species", palette = c("#a6cee3", "#fdbf6f"))
p2 + stat_compare_means(comparisons = list(c("Blue Whale", "Humpback Whale")))

```

There is a wide range of similarity measures (or dissimilarity, i.e., 1-similarity) that allow us to understand the relationships between our samples. Generally speaking, they all calculate comparable distance matrices. The `phyloseq` package offers a great number of distance measurements. The most popular ones are UniFrac and Weighted UniFrac (both of them consider phylogeny) and others independent from phylogeny, such as Jaccard, Manhattan, Euclidean, Bray-Curtis, Canberra, etc. In the other hand, the resulting distance matrix is not used in isolation, but rather conjoined with an ordination or multidimensional scaling tools. Then again, `phyloseq` offers a variety of said tools, including detrended and canonical correspondence analysis, Double Principal Coordinate Analysis, Non-metric MultiDimensional scaling, and MDS/PCoA.

We'll begin by trying to make a PCoA analysis with a distance matrix that accounts for phylogenetic relationships and another one that doesn't. 

```{r}
# ordination first (summarizes data from the community)
psd5.mds.unifrac <- ordinate(psd5, method = "MDS", distance = "unifrac") # the method can be changed as well as how is the distance calculated
evals <- psd5.mds.unifrac$values$Eigenvalues #extracting the eigenvalues from the ordination object
pord1 <- plot_ordination(psd5, psd5.mds.unifrac, color = "geo_loc_name") + # plot
  labs(col = "geo_loc_name") +
  coord_fixed(sqrt(evals[2] / evals[1]))

psd5.mds.bray <- ordinate(psd5, method = "MDS", distance = "bray")
evals <- psd5.mds.bray$values$Eigenvalues
pord2 <- plot_ordination(psd5, psd5.mds.bray, color = "geo_loc_name") +
  labs(col = "geo_loc_name") +
  coord_fixed(sqrt(evals[2] / evals[1]))

grid.arrange(pord1, pord2)
```

Let's note that the dispersion graphs in which the analysis is portrayed are scaled based on the variation each of the axis explain. Generally speaking, these methods try to find the least amount of mathematical vectors that maximize the separation between our samples (the dots in the graphs); this is due to the fact that it is almost impossible to represent visually and effectively multidimensional data. The data we're working with is multidimensional in the sense that we're working with more than a 100 taxa that may also vary simultaneously in each of the more than 90 sample we have. The axis themselves don't add up to the 100% because there are other axis absent in our plot that represent the rest of the variation. When plotting symmetrically, we distort the relationship between the dots, specially when comparing two or more graphs.

With microbial communities, the double principal coordinate analysis (DPCoA) is rather appropriate since it analyzes two data types at the same time: a similarity table that represents the differences among species and an abundance matrix that represents the species' distribution among the communities. The final product is an ensemble of the multidimensional space that correlates the species with the communities. This method was published in [2004](https://www.sciencedirect.com/science/article/abs/pii/S0022519304000736). We want to see this with our data.

```{r}
psd5.dpcoa.unifrac <- ordinate(psd5, method = "DPCoA", distance = "dpcoa") # we ordinate once again
evals <- psd5.dpcoa.unifrac$eig # we extract the eigenvalues
pord3 <- plot_ordination(psd5, psd5.dpcoa.unifrac, color = "species", shape = "geo_loc_name") + #the plot
  labs(col = "Species") +
  coord_fixed(sqrt(evals[2] / evals[1])) +
  scale_color_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f")) + 
  scale_fill_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f")) +
  geom_point(size=4)
pord3
```

Now, we wish to explore the multidimensional scaling using the t-SNE or the t-Distributed Stochastic Neighbor Embedding methods. *t-SNE* is different from other methods since it emphasizes in local distances rather than global ones, generating a bigger resolution o separation between the samples in this way.

```{r}
library(tsnemicrobiota)
# we are directly applying the method, we must account for the distance, the majority of arguments I don't understand
tsne_res <- tsne_phyloseq(psd5, distance= "dpcoa", perplexity = 8, verbose=0, rng_seed = 3901)

# Graph
pord4 <- plot_tsne_phyloseq(psd5, tsne_res, color = "species", shape = "geo_loc_name") +
  geom_point(size=4) +
  scale_color_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f")) + 
  scale_fill_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f"))

grid.arrange(pord3, pord4)
```

Both graphs use different methods but the same distance measure. The results are similar, however, the grouping of the samples lie in different arrangements. We may also visualize these measurements with sample density in sapce.

```{r}
library(Rtsne)
# declaring the methods we'll be using
method <- "tsne"
trans <- "hellinger"
distance <- "euclidean"

# distance matrix
# it takes a phyloseq object and then transforms it using the stated method, can be any  from the vegan::decostand 
psd5 <- microbiome::transform(psd5, trans)

# we calculate similarity
dm <- vegdist(otu_table(psd5), distance)

# t-SNE scaling method
tsne_out <- Rtsne(dm, dims = 2, perplexity = 8) # the scaling with the t-SNE
proj <- tsne_out$Y #don't really get what they're extracting
rownames(proj) <- rownames(otu_table(psd5)) # row names assigning
data.frame(proj) -> proj #making a data frame
proj$species <- sample_data(psd5)[,11]# extracting species from the object

pland <- plot_landscape(proj[,1:2], legend = T, size = 4, method = "t-SNE") # plotting the object (can be phyloseq or a matrix)
print(pland)
```

# Visualization and abundance analysis

## Stacked bar graph

We can get a general idea of our samples' composition via the use of a stacked bar graph. There are many ways in which we can create said graphs, nonetheless, we'll be using the package made by an ex-member from the authors' lab since it can group the samples *hierarchical clustering* as well as other useful tools.

```{r, warning=FALSE}
# We'll be using the top 15 most abundant taxa
# the function subsets the data to obtain the n most abundant taxa, can be relative or absolute counts.
top15 <- get_top_taxa(physeq_obj = psd5, n = 15, relative = T,
                       discard_other = T, other_label = "Other")

# Since we don't have a fully species resolution for each of the taxa, we generate labels composed of different taxonomic ranges for the graph
top15 <- name_taxa(top15, label = "", species = F, other_label = "Other")

# plotting
fantaxtic_bar(top15, color_by = "Family", label_by = "Genus", facet_by = NULL, grid_by = NULL, other_color = "Grey") -> ptop15

ptop15
```

We can have a general idea of the composition of the samples jut by looking at the graph above, but we can subset the samples and data into each of the whales. The function `fantaxtic_bar` offers the possibility of separating the graph with the arguments `facet_by` and `grid_by`.

```{r, warning=FALSE}
fantaxtic_bar(top15, color_by = "Family", label_by = "Genus", facet_by = "species", grid_by = NULL, other_color = "Grey") -> ptop15.2

ptop15.2
```

## Different abundace visualization

Now we may see and use other tools that allow us to examine the composition of the microbial communities. The package `ampvis2`, which was developed by Mads Albertsen and Kasper Skytte Andersen, makes this examination possible. First of all, we transform the `phyloseq` object which we have worked with up until now into an `ampvis2` object.

```{r}
library(ampvis2)

# We need to extract the read count table and the taxonomy table from our psd5 object 
# We generate a new object in order to avoid modifying the original object 

obj <- psd5

# we tranbspose the otu_table
t(otu_table(obj)) -> otu_table(obj)

# Extract the tables 
otutable <- data.frame(OTU = rownames(phyloseq::otu_table(obj)@.Data),
                       phyloseq::otu_table(obj)@.Data,
                       phyloseq::tax_table(obj)@.Data,
                       check.names = FALSE)

# get the metadata from the object
metadata <- data.frame(phyloseq::sample_data(obj), 
                       check.names = FALSE)

# ampvis2 requieres 1.- for the taxomonic ranges to be seven and go from Kingdom to Species and 2.- the first column of the metadata to be the id of each sample 
# We now duplicate the genus column and we change the name to species 
otutable$Species = otutable$Genus

# Rearrange the metadata
metadata <- metadata[,c("run","sample_ID","bioproject_accession","study","biosample_accession","experiment","SRA_Sample","geo_loc_name","collection_date","sample_type","species","common_name","AvgSpotLen")]

# We create the ampvis object
av2 <- amp_load(otutable, metadata)
```

Now let us have a look at the community structure using *rank abundance curves*.

```{r}
amp_rankabundance(av2, group_by = "species")
```

The graph shows us the increment of cumulative abundance reads as we sum the taxa from bigger to lower abundance (*Rank abundnace*). The important thing to notice is the curve. A curve that peaks rapidly indicate that the communities are dominated by few taxa_; in the other hand, when the peak is slow just like in the observed data, the most abundant taxa onl represent about 25% of the cumulative reads.

We'll now visualize which taxa correspond to the 25%. For this prupose, we'll be using the function `amp_heatmap`.

```{r}
amp_heatmap(av2, 
            group_by = "species", 
            facet_by = "geo_loc_name", 
            plot_values = TRUE,
            tax_show = 20,
            tax_aggregate = "Genus",
            tax_add = "Phylum",
            plot_colorscale = "sqrt",
            plot_legendbreaks = c(1, 5, 10))
```

*Tenacibalum* seems to be the most abundant genus for most of the samples, except *Balaenoptera physalus* and *Megaptera novaeangliae*, whose most abundant microorganism appears to be *Stenotrophomonas*. Apparently these data seems to be within the current literature. 

We'll also use a boxplot visualization for better understanding.

```{r}
amp_boxplot(av2,
            group_by = "species",
            tax_show = 20,
            tax_aggregate = "Genus",
            tax_add = "Phylum",
            adjust_zero = T,
            plot_log = T) +
  scale_color_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f")) + 
  scale_fill_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f"))
```

Now, we can see if any of these microorganisms are shared between the samples. For this purpose we must calculate the core microbiome or the portion of the shared taxa between a certain percentage threshold of the samples and the in-sample prevalence.

**This doesn't really work, nor should it return the image presented in the original work.**
Most probably the final plot was with another function, since `amp_core` doesn't even have the possibility of using the argument `tax_aggregate`.
```
amp_core(av2, 
         tax_aggregate = "Family",
         group_by = "Sample",
         abund_thrh = 0.5)
```

Visualize with a Venn diagram.

```{r}
amp_venn(av2, group_by = "species", cut_a = 0, cut_f = 50, text_size = 3)
```

## Microorganism differential abundance analysis

Up until now, we have mostly seen exploratory analysis and some statistical tests for alpha and beta diversities, nut there are many times in which we want to determine exactly how much and which taxa is more represented in a condition versus another one. The process is analog to the gene differential expression in transcriptomics, e.g.,RNA-seq. The resemblance is such that we use one of the most widely used packages in transcriptomic, DESeq2. Now, our samples were sequenced at the same time and an effort was made for them to have a uniform depth between all samples. In practice this is not the case most of the times, so most often than not we must fix two situations when in the context of differential abundance analysis. The first is the unequal size of the samples (number of reads) and the data variability correlation to the mean of them. For this last situation, we can make use of a transformation called *Variance Stabilizing Transformation*; this transformation has as objective to find a function $f$ that will be applied to the read counts, so that in the new values $y=f(x)$, the variability gives and don't relate to it's mean values.

We start off by transforming the data.


```{r}
# We create a DESeq2 object with the function `phyloseq_to_deseq2`
diagdds <- phyloseq_to_deseq2(psd5, ~species)

# We calculate the size factors as part of the normalization of the samples
# calculate geometric means prior to estimate size factors
gm_mean <- function(x, na.rm=TRUE){
    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
}
geoMeans <- apply(counts(diagdds), 1, gm_mean)
diagdds <- estimateSizeFactors(diagdds, geoMeans = geoMeans)

# Normalizamos y realizamos el test paramétrico de Wald para determinar taxa diferencialmente abundante.
diagdds <- DESeq(diagdds, test="Wald", fitType="local")
```












